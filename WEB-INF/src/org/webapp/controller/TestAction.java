/**
 * Xinkai He, xinkaih@andrew.cmu.edu, 46-864, March 24 2012
 */
package org.webapp.controller;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Random;
import java.util.TimeZone;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.genericdao.RollbackException;
import org.mybeans.form.FormBeanException;
import org.webapp.controller.annotations.ActionName;
import org.webapp.dao.CommentDAO;
import org.webapp.dao.FriendshipDAO;
import org.webapp.dao.StoryDAO;
import org.webapp.dao.UserDAO;
import org.webapp.entity.Comment;
import org.webapp.entity.Friendship;
import org.webapp.entity.Photo;
import org.webapp.entity.Story;
import org.webapp.entity.User;
import org.webapp.model.Model;
import org.webapp.model.PhotoDAO;
import org.xinkaih.util.StringUtil;

/**
 * The action that populate the website with persistent objects.
 * Including User, Friendships, Stories and Comments.
 * <br>This Action runs dao.getCount() before persistent operation to ensure the database is clear.
 * If there are entries in the database the operation won't be carried on.
 *  
 * By default, the user generated will have:
 * <br>username: test+<sequence=id generated by DAO>
 * <br>first name: TFname_+&lt;sequence&gt;
 * <br>last name: TLname++&lt;sequence&gt;
 * <br>Timezone: eastern time/us. Although I can do it randomly, but this is manually modifiable through profile update.
 * 
 * <hr>The story post time is set ten days before current date. And the comments's date is based on story's post dates, which the comment belongs to.
 * @author Administrator
 *
 */

@ActionName("test.do")
@SuppressWarnings({ "unchecked", "rawtypes" })
public class TestAction extends Action{
	
	PrintStream stdout = null;
	
	private CommentDAO comDao;
	private StoryDAO stDao;
	private UserDAO uDao;
	private FriendshipDAO fDao;
	private PhotoDAO photoDAO;
	// random dict for comments and story contents
	private RandomDict dict;
	// random dict for first name
	private RandomDict fnameDict = new RandomDict(new String[]{"Geraldine","Lorraine","Melanie","Lindsey","Kristi","Reba","Rachelle","Kirsten","Winnie","Jerry","Hollie","Charles","Kevin","Nicholas","Lloyd","Roberto","Ted"});
	// random dict for last name
	private RandomDict lnameDict = new RandomDict(new String[]{"Gray ","Gutierrez ","Hoffman ","Valdez ","Brock ","Bryan ","Wilcox ","Henson ","Blankenship ","Mahoney ","Valentine ","Hayden ","Brandt ","Faulkner ","Osborn "});
	// **UNUSED**. random Time zone ID's dictionary
	@SuppressWarnings("unused")
	private RandomDict tzDict = new RandomDict(TimeZone.getAvailableIDs());
	/**
	 * If set to false, the action will only provide a log file that records all the objects generated.
	 * If set to true, will call DAO to persistentiate.
	 */
	static final boolean daoOper = true;
	
	static final String DEFAULT_PASSWORD = "123";
	static final int DEFAULT_USER_COUNT = 20;
	
	private ServletContext context;
	
	private Random rdm = new Random();

	public TestAction(Model model, ServletContext context) {
		super(model);
		this.context = context;
		if(daoOper){
		this.comDao = model.getCommentDAO();
		this.stDao = model.getStoryDAO();
		this.uDao = model.getUserDAO();
		this.fDao = model.getFriendshipDAO();
		this.photoDAO = model.getPhotoDAO();
		}
	}

	@Override
	public String perform(HttpServletRequest request) throws RollbackException,
			FormBeanException {
		int ucount=0, fcount=0, scount=0, ccount=0, count2 =0;
		
		request.setAttribute("userCount", ucount);
		request.setAttribute("friendshipCount", fcount);
		
		if(daoOper){
			ucount = uDao.getCount();
			fcount = fDao.getCount();
			scount = stDao.getCount();
			ccount = comDao.getCount();
			count2 = scount+ccount+fcount;
			request.setAttribute("userCount", ucount);
			request.setAttribute("friendshipCount", fcount);
		}
		if(ucount!=0||count2!=0){
			errors.add("The data base needed to be totally cleaned(all tables don't have entries) before the test:user count:"+ucount+" other entries count:"+count2);
			return "welcome.jsp";
		}
		
		// create users
		// create for every user a constant number of friends
		// create story posts for every users
		// create comment for these posts.
		// the loop of the story/comment creation:
		// for every user, 
		create();
		if(!daoOper){
			messages.add("The persistence process not carried out due to the configuration of daoOper.");
		}else{
			messages.add("Population succeeded. Login with username: [test1] to [test"+DEFAULT_USER_COUNT+"] and password["+DEFAULT_PASSWORD+"]");
			request.setAttribute("userCount", uDao.getCount());
			request.setAttribute("friendshipCount", fDao.getCount());
		}
		return "welcome.jsp";
	}
	
	private void create() throws RollbackException{
		// load the random string generator
		loadRdmStringGenerator();
		// generate user profile pictures
		Photo[] photos = createPhotos(DEFAULT_USER_COUNT);
		// generate users
		User[] users = createUsers(DEFAULT_USER_COUNT, photos);
		
		stdout.println(Arrays.toString(users));
		// every user will have at most 21 friends. Of course here there are only 10 users generated so at most 9. But the final count is generated randomly
		// so might be different for each users.
		UserFriends[] ufs = createRdmFships(users, 21);
		// five indicates that every user will create at most 5 stories. 
		createStoryComments(ufs, 5);
	}
	
	/**
	 * The photos are generated from /images/01-49.jpg
	 * 
	 * @param count
	 * @return
	 * @throws RollbackException 
	 */
	private Photo[] createPhotos(int count) throws RollbackException{
		Photo[] photos = new Photo[count];
		if(context==null)
			throw new AssertionError("Need servlet context to create photos.");
		for(int i = 0;i<count;i++){
			int c = rdm.nextInt(49)+1;
			StringBuilder sb = new StringBuilder();
			sb.append("images/");
			if(c<10){
				sb.append('0');
			}
			sb.append(c).append(".jpg");
			Photo p =createProfilePic(context.getResourceAsStream(sb.toString()));
			if(daoOper)
				photoDAO.createAutoIncrement(p);
			photos[i] = p;
			stdout.println("Photo created:"+sb.toString());
		}
		return photos;
	}
	
	private Photo createProfilePic(InputStream filestream){
		Photo p = new Photo();
		BufferedInputStream in = null;
		ByteArrayOutputStream out = null;
		try{
			out = new ByteArrayOutputStream(2000);
			in = new BufferedInputStream(filestream);
			byte[] bts = new byte[2000];
			int count = 0;
			while((count = in.read(bts))!=-1){
				out.write(bts, 0, count);
			}
			p.setBytes(out.toByteArray());
			p.setContentType("image/jpeg");
		} catch (IOException e) {
			// Shouldn't happen.
			throw new AssertionError(e);
		}finally{
			try {
				if(in!=null)
					in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return p;
	}
	
	private void loadRdmStringGenerator(){
		try {
			File f = new File("debug.txt");
			System.out.println("INFO:debug file path "+f.getAbsolutePath());
			stdout = new PrintStream(new FileOutputStream(f),true);
			// initialize the random sentence dictionary
			dict = RandomDict.load("test.txt");
		} catch (IOException e) {
			System.out.println("INFO:"+this.getClass().getName()+":"+e);
			try {
				System.out.println("INFO:"+this.getClass().getName()+":will try another.");
				dict = RandomDict.load(context.getResourceAsStream("test.txt"));
			} catch (IOException e1) {
				System.out.println("INFO:"+this.getClass().getName()+":"+e);
				System.out.println("INFO:"+this.getClass().getName()+":will try the default random string array.");
				dict = new RandomDict(new String[]{"hello", "howareyou?", 
						"this is a wonderful new great day", "i couldn't be better.", 
						"What's up man?", 
						"What's up girl?", 
						"hahaha. that's really funny.", 
						"the story is wonderful. don't you think so?", 
				"I heard something from whitehouse today, they don't like potus."});
			}
		}
	}
	
	private User[] createUsers(int size, Photo[] photos) throws RollbackException{
		User[] users = new User[size];
		// the user's count begins from 1, for MySQL's id increment begins from 1.
		for(int i = 1;i<=size;i++){
			String username = "test"+i;
			String password = DEFAULT_PASSWORD;
			String firstname = fnameDict.nextWord();
			String lastname = lnameDict.nextWord();
			String timezone = "US/Eastern";
			User user = new User(username, password, firstname, lastname, timezone);
			// load randomly from the photos
			if(photos!=null){
				Photo p = null;
				if(photos.length<size){
					// randomly choose a photo
					p = photos[rdm.nextInt(photos.length)];
				}else{
					p = photos[i-1];
				}
				if(p!=null)
					user.setProfilePicId(p.getId());
			}
			if(daoOper)
				uDao.createAutoIncrement(user);
			// to cancel the effect of i+1 at the beginning, deduct 1 here.
			users[i-1] = user;
		}
		return users;
	}
	
	private static class UserFriends{
		User user;
		User[] friends;
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("UserFriends [user=").append(user)
					.append(", friends=").append(Arrays.toString(friends))
					.append("]");
			return builder.toString();
		}
	}
	
	/**
	 * 
	 * 
	 * @param usres can't be unll, users must have the user id not 0
	 * @param size how many friendships needed for each of the users.
	 * @return a view contains both user and the friend list.
	 */
	private UserFriends[] createRdmFships(User[] users, int size) throws RollbackException{
		// for each of the user that come in
		// add to him randomly selected uses as friend.
		// generate list 1-10, shuffle the list, add the first five as friend, then
		if(size>users.length)
			size = users.length-1;
		// create an array to hold all the user->friends realtions.
		UserFriends[] ufs = new UserFriends[users.length];
		// create an array to hold all the newly created friendships
		Friendship[] fs = new Friendship[size*users.length];
		List<Integer> numList = new ArrayList<Integer>();
		// prepare the index list
		for(int i = 0;i<size+1;i++){
			numList.add(i);
		}
		// for each of the users
		for(int i = 0;i<users.length;i++){
			UserFriends uf = new UserFriends();
			User src = users[i];
			uf.user = src;
			// add [size] friends
			Collections.shuffle(numList);
			// create an array to hold a users generated friends.
			// it's length is randomized and smaller than the given friend upper limit
			int rdmsize = rdm.nextInt(size)+1;
			User[] friends = new User[rdmsize];
			for(int j = 0;j<friends.length;j++){
				User dst = users[numList.get(j)];
				// if there is the src user also in the list, then take the extra user as the dst one
				if(dst.getId()==src.getId()){
					dst = users[numList.get(size)];
				}
				Friendship f = new Friendship();
				f.setSrcId(src.getId());
				f.setDstId(dst.getId());
				if(daoOper)	fDao.createAutoIncrement(f);
				fs[i*(size-1)+j] = f;
				friends[j] = dst;
			}
			uf.friends = friends;
			ufs[i] = uf;
//			stdout.println(uf);
		}
		return ufs;
	}
	
	private void createStoryComments(UserFriends[] ufs, int storyCount) throws RollbackException{
		int size = ufs.length;
		for(int i = 0;i<size;i++){
			UserFriends uf = ufs[i];
			for(int j = 0;j<storyCount;j++){
				Story s = createStory(uf.user);
				// create comments for the story
				for(int k = 0;k<uf.friends.length;k++){
					int lucky = rdm.nextInt(10);
					if(lucky<=6){
						// randomly create friends' comment
						createComment(uf.friends[k], s);
						if(lucky<=3){
							// user's reply does not count the total count of comments.
							k--;
							// randomly create story owner's comment
							createComment(uf.user, s);
						}
					}
				}
			}
		}
	}
	
	private Comment createComment(User owner, Story story) throws RollbackException{
		Long timeMillis = story.getDate().getTime();
		// generate random time for the comment that varies(after) within 10 days range of the story
		timeMillis = timeMillis+rdm.nextInt(1000*3600*24*10);
		Date date = new Date(timeMillis);
		Comment c = new Comment(owner, story, generateRdmStr(), date);
		if(daoOper) comDao.createAutoIncrement(c);
		stdout.println("               Comment created:"+c);
		return c;
	}
	
	/**
	 * Create a story that is posted by current user and have the posted date
	 * at least 11 days before the current calendar date. So the comment won't go beyond the current date after adding at most 10 days
	 * 
	 * @param user
	 * @return
	 * @throws RollbackException
	 */
	private Story createStory(User user) throws RollbackException{
		Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(user.getTimezone()));
		cal.setTime(new Date());
		// random days deducted, greater than 11 smaller than 30
		int rddays = rdm.nextInt(20)+11;
		// deduce the days from current date
		cal.add(Calendar.DAY_OF_MONTH, -rddays);
		cal.set(Calendar.HOUR_OF_DAY, rdm.nextInt(24));
		cal.set(Calendar.MINUTE, rdm.nextInt(60));
		cal.set(Calendar.SECOND, rdm.nextInt(60));
		Date date = cal.getTime();
		Story s = new Story(user, generateRdmStr(), generateRdmStr(), date);
		if(daoOper)
			stDao.createAutoIncrement(s);
		stdout.println("Story created:"+s);
		return s;
	}
	
	/**Generate some random string. Sanitized.*/
	private String generateRdmStr(){
		if(dict!=null)
			return StringUtil.sanite(dict.nextWord());
		return "dictionary failed to be initialized.";
	}
	
	public static void main(String[] args) throws RollbackException {
		TestAction test = new TestAction(null, null);
		User[]	users  = test.createUsers(20, null);
		UserFriends[] ufs = test.createRdmFships(users, 21);
		test.createStoryComments(ufs, 5);
	}
	
	@Override
	protected void finalize() throws Throwable {
		super.finalize();
		if(!System.out.equals(this.stdout)&&stdout!=null){
			stdout.close();
		}
	}
}

class RandomDict {
    public static final String[] NO_STRINGS = {};
    final Random random = new Random();
    final String[] words;

    public RandomDict(String[] words) {
        this.words = words;
    }

    public static RandomDict load(InputStream file) throws IOException {
    	if(file==null){
    		throw new IOException("Input strem is null while trying to load the dictionary.");
    	}
        BufferedReader br = new BufferedReader(new InputStreamReader(file));
        List<String> words = new ArrayList<String>();
        
        try {
            for (String line; (line = br.readLine()) != null; ) {
//                if (line.indexOf('\'') >= 0) continue;
                words.add(line.toLowerCase());
            }
        } finally {
            br.close();
        }
        return new RandomDict(words.toArray(NO_STRINGS));
    }
    
    public static RandomDict load(String filename) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filename));
        List<String> words = new ArrayList<String>();
        
        try {
            for (String line; (line = br.readLine()) != null; ) {
//                if (line.indexOf('\'') >= 0) continue;
                words.add(line.toLowerCase());
            }
        }finally {
            br.close();
        }
        return new RandomDict(words.toArray(NO_STRINGS));
    }
    
    

    public String nextWord() {
        return words[random.nextInt(words.length)];
    }
    
    
}